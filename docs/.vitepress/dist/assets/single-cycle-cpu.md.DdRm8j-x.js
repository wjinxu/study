import{_ as n,c as l,o as e,j as i,ae as t,a as p,t as h}from"./chunks/framework.BQcVUm0h.js";const y=JSON.parse('{"title":"single-cycle-cpu项目使用指南","description":"","frontmatter":{"title":"single-cycle-cpu项目使用指南","editLink":true,"layout":"doc"},"headers":[],"relativePath":"single-cycle-cpu.md","filePath":"single-cycle-cpu.md"}'),k={name:"single-cycle-cpu.md"},d={id:"frontmatter-title",tabindex:"-1"};function r(a,s,c,o,g,E){return e(),l("div",null,[i("h1",d,[p(h(a.$frontmatter.title)+" ",1),s[0]||(s[0]=i("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1))]),s[1]||(s[1]=t(`<div class="tip custom-block"><p class="custom-block-title">注意事项：使用最新的项目代码和文档！</p><p>项目会持续修复一些错误或增加一些对用户友好的内容，因此项目和文档会有不间断的更新，我们需要使用最新的项目和文档</p><p>关于项目：如果你已经克隆了项目, 可以在项目目录下使用<code>git pull</code>来获取最新的项目代码。 <br>关于文档：文档的最新版本会直接呈现在网页上，可以多留意网页上新增了哪些内容</p><p>有关<code>git pull</code>命令的详细使用，可以通过AI来获得更多的信息。</p></div><h2 id="一、项目介绍" tabindex="-1">一、项目介绍 <a class="header-anchor" href="#一、项目介绍" aria-label="Permalink to &quot;一、项目介绍&quot;">​</a></h2><p>该项目是一个RISC-V单周期处理器仿真、测试框架。你可以将你的单周期处理器接入到该框架中，用于验证自己的处理器实现是否正确，也可以在自己的处理器上运行一些简单的软件程序。</p><p>支持的指令集:RV32IM</p><p><strong>项目主要目录如下</strong>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>single-cycle-cpu</span></span>
<span class="line"><span>├── abstract-machine                 # 裸机运行时环境(目前忽略它)</span></span>
<span class="line"><span>├── IP                               # 处理器代码目录</span></span>
<span class="line"><span>│    ├── mycpu                          # 此目录用于接入你的单周期处理器</span></span>
<span class="line"><span>│    ├── single-cycle-cpu               # 项目内置的一个单周期处理器(verilog)</span></span>
<span class="line"><span>│    └── single-cycle-cpu-master        # 项目内置的一个单周期处理器(verilog)</span></span>
<span class="line"><span>├── software-test                    # 测试处理器的软件程序</span></span>
<span class="line"><span>│    ├── benchmarks                     # benchmark测试程序</span></span>
<span class="line"><span>│    │   cpu-tests                      # 简单cpu测试程序</span></span>
<span class="line"><span>├── simulator                        # 处理器模拟仿真框架</span></span>
<span class="line"><span>│    ├── include                        </span></span>
<span class="line"><span>│    │   nemu                           # 用于difftest的nemu动态链接库目录</span></span>
<span class="line"><span>│    │   src                            # 源代码目录</span></span>
<span class="line"><span>│    └── Makefile                       </span></span>
<span class="line"><span>├── Makefile                         </span></span>
<span class="line"><span>└── README.md</span></span></code></pre></div><h2 id="二、实验环境搭建" tabindex="-1">二、实验环境搭建 <a class="header-anchor" href="#二、实验环境搭建" aria-label="Permalink to &quot;二、实验环境搭建&quot;">​</a></h2><h3 id="配置一览" tabindex="-1">配置一览 <a class="header-anchor" href="#配置一览" aria-label="Permalink to &quot;配置一览&quot;">​</a></h3><ul><li>操作系统： ubuntu 22.04(LTS), 非root账户</li><li>仿真工具： Verilator、GTKwave</li><li>编译工具： RISC-V</li><li>编程语言： Verilog HDL、C语言</li></ul><h3 id="安装ubuntu系统" tabindex="-1">安装ubuntu系统 <a class="header-anchor" href="#安装ubuntu系统" aria-label="Permalink to &quot;安装ubuntu系统&quot;">​</a></h3><p><a href="./install-ubuntu.html">点击此处查看相关资料</a><br></p><div class="tip custom-block"><p class="custom-block-title">记得更换Ubuntu软件源</p><p>由于 Ubuntu 默认软件源在国内访问速度较慢，我们建议大家更换为国内的软件源，例如<a href="https://mirrors.bfsu.edu.cn/help/ubuntu/" target="_blank" rel="noreferrer">北外镜像源</a>。</p><p>在更换软件源后，请使用 sudo apt update 命令更新索引。</p></div><h3 id="安装verilator" tabindex="-1">安装Verilator <a class="header-anchor" href="#安装verilator" aria-label="Permalink to &quot;安装Verilator&quot;">​</a></h3><p>Verilator 是一款开源的支持 Verilog 和 SystemVerilog 仿真工具。它能够将给定的电路设计翻译成 C++ 或者 SystemC 的库等中间文件，最后使用 C/C++ 编写激励测试，去调用前面生成的中间文件，由 C/C++ 编译器编译执行，来完成仿真。此外，它也具有静态代码分析的功能。</p><p>如果你想要自己编译安装Verilator, 可以参考<a href="https://verilator.org/guide/latest/install.html" target="_blank" rel="noreferrer">官方文档</a>、CSDN、和知乎。本文主要对文档内容进行整理，并补充一些细节。 你也可以执行下列命令直接安装verilator:</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> verilator</span></span></code></pre></div><h3 id="安装gtkwave" tabindex="-1">安装GTKwave <a class="header-anchor" href="#安装gtkwave" aria-label="Permalink to &quot;安装GTKwave&quot;">​</a></h3><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> gtkwave</span></span></code></pre></div><h3 id="安装库文件和编译工具" tabindex="-1">安装库文件和编译工具 <a class="header-anchor" href="#安装库文件和编译工具" aria-label="Permalink to &quot;安装库文件和编译工具&quot;">​</a></h3><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apt-get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build-essential</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apt-get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> libreadline-dev</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apt-get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> llvm-dev</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apt-get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> g++-riscv64-linux-gnu</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> binutils-riscv64-linux-gnu</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>目前仍有一部分工具, 暂未提供安装命令，后续会陆续添加支持。</p></div><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h3><h2 id="三、初次运行项目" tabindex="-1">三、初次运行项目 <a class="header-anchor" href="#三、初次运行项目" aria-label="Permalink to &quot;三、初次运行项目&quot;">​</a></h2><h3 id="_1-获取项目代码" tabindex="-1">1. 获取项目代码 <a class="header-anchor" href="#_1-获取项目代码" aria-label="Permalink to &quot;1. 获取项目代码&quot;">​</a></h3><p>在命令行或终端环境下，执行下列命令获取项目代码</p><p>如果之前已经执行过下面代码克隆过该项目，可以在项目目录下使用<code>git pull</code>来获取最新代码 <br>或者也可以将已经克隆的项目删除掉之后，再执行下面的命令。 <br>有关<code>git pull</code>的一些使用方法，可以通过询问<code>AI</code>得知</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clone</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git@github.com:cs-prj-repo/single-cycle-cpu.git</span></span></code></pre></div><p>如果使用上述的git克隆失败，可以使用下面的命令</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clone</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://github.com/cs-prj-repo/single-cycle-cpu.git</span></span></code></pre></div><p>如果再次克隆失败并且使用的是虚拟机，可以通过下载压缩包并且使用<code>scp</code>相关命令，将文件拷贝到虚拟机里面。</p><h3 id="_2-设置环境变量" tabindex="-1">2. 设置环境变量 <a class="header-anchor" href="#_2-设置环境变量" aria-label="Permalink to &quot;2. 设置环境变量&quot;">​</a></h3><p>在你的<code>~/.bashrc</code>文件当中添加如下的环境变量，添加完成后，执行<code>source ~/.bashrc</code>命令 <br>有关如何添加环境变量，可以通过询问<code>AI</code>得知</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CPU_HOME</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">single-cycle-cpu目录的绝对路径 </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#复制后记得修改,注意记得是绝对路径</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SIM_HOME</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$CPU_HOME/simulator          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#直接复制即可</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AM_HOME</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$CPU_HOME/abstract-machine    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#直接复制即可</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TEST_HOME</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$CPU_HOME/software-test     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#直接复制即可</span></span></code></pre></div><h3 id="_3-运行项目框架默认的处理器和内置程序" tabindex="-1">3. 运行项目框架默认的处理器和内置程序 <a class="header-anchor" href="#_3-运行项目框架默认的处理器和内置程序" aria-label="Permalink to &quot;3. 运行项目框架默认的处理器和内置程序&quot;">​</a></h3><p>在命令行或终端环境下执行下面命令，尝试使用项目框架默认的处理器运行内置程序。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $SIM_HOME</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span></span></code></pre></div><p>如果项目运行后出现一个绿色的<code>HIT GOOD TRAP</code>，说明程序运行成功，一切正常。</p><p>如果项目运行后出现编译报错，请自行修复，或联系我们并提供报错截图，帮助我们修复错误。</p><p>如果项目运行后出现一个红色的<code>HIG BAD TRAP</code>, 说明处理器执行指令时出错，一般是处理器实现问题。</p><div class="tip custom-block"><p class="custom-block-title">项目框架的仿真环境对于访存的要求</p><p>目前项目框架支持的内存为128MB, 地址空间为[0x80000000, 0x8fffffff], 注意在访存时不要超出该地址空间范围</p></div><div class="tip custom-block"><p class="custom-block-title">处理器运行的内置程序</p><p>当在<code>simluator</code>目录下执行<code>make run</code>时，无论项目指定哪个处理器运行，都会运行一个内置的程序 这段内置程序指令存放在<code>simulator/src/monitor/monitor.c</code>文件下，其名称为<code>static const uint32_t img[]</code></p><p>在运行你的处理器的时候，你可以根据自己的需要来修改此处代码来运行指定的程序指令</p><p>注意内置程序指令一定要包含一条<code>ebreak</code>指令</p></div><div class="tip custom-block"><p class="custom-block-title">仿真环境如何判定程序执行结束</p><p>项目框架通过指定<code>ebreak</code>指令为程序结束的指令来判断一个程序是否运行结束。</p><p>在执行程序时，项目框架会在每个程序的最后注入一条<code>ebraek</code>指令来达到该效果。</p><p>由于内置程序是用户可以自行修改的，所以内置程序的<code>ebreak</code>指令需要由用户自己添加。</p></div><div class="tip custom-block"><p class="custom-block-title">开启/关闭Difftest</p><p>项目需要使用DIfftest技术来验证处理器实现是否正确。</p><p>项目中Difftest默认处于开启状态</p><p>在<code>simulator/inlcude/utils/open_sim_difftest.h</code>文件中 可以通过注释或者解开注释<code>#define CONFIG_DIFFTEST 1</code>来打开或关闭Difftest功能</p><p>注意，开启Difftest会减缓程序运行时间，在进行benchmarck程序对处理器进行跑分时，建议关闭Difftest</p></div><div class="tip custom-block"><p class="custom-block-title">开启/关闭波形追踪</p><p>在处理器运行时，仿真框架可以追踪到处理器运行程序的波形信息。</p><p>项目默认波形追踪处于关闭状态</p><p>在<code>simulator/inlcude/utils/open_sim_difftest.h</code>文件中 可以通过注释或者解开注释<code>#define CONFIG_NPC_OPEN_SIM 1</code>来打开或关闭波形追踪功能</p><p>谨记，如果开启波形运行大型，则会生成非常大的波形文件，高达1G-50GB，有可能会损害磁盘</p><p>因此，当运行一些大型程序时，比如benchmark，一定不要开启波形追踪。</p><p>如何使用更小的波形文件格式，如fst，正在开发中。</p></div><h3 id="_4-修复riscv32编译错误" tabindex="-1">4. 修复riscv32编译错误 <a class="header-anchor" href="#_4-修复riscv32编译错误" aria-label="Permalink to &quot;4. 修复riscv32编译错误&quot;">​</a></h3><p>第一次运行下面的命令，会出现一个编译错误，我们来修复它。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $TEST_HOME</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/cpu-tests</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ARCH=riscv32-npc</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ALL=dummy</span></span></code></pre></div><p>如果遇到了以下错误: <br><code>/usr/riscv64-linux-gnu/include/bits/wordsize.h:28:3: error: #error &quot;rv32i-based targets are not supported&quot;</code><br>那么使用<code>sudo</code>权限修改<code>/usr/riscv64-linux-gnu/include/bits/wordsize.h</code>文件</p><div class="language-vim vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vim</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> #if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> __riscv_xlen </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 64</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> #</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> define</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> __WORDSIZE_TIME64_COMPAT32 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> #else</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    #</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> error </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;rv32i-based targets are not supported&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -----&gt;将这一行注释掉</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    #</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> define</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> __WORDSIZE_TIME64_COMPAT32 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           -----&gt;在下面新增这一行</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> #endif</span></span></code></pre></div><p><br>如果遇到了以下错误： <br><code>/usr/riscv64-linux-gnu/include/gnu/stubs.h:8:11: fatal error: gnu/stubs-ilp32.h: No such file or directory</code><br>那么使用<code>sudo</code>权限修改<code>/usr/riscv64-linux-gnu/include/gnu/stubs.h</code>文件 <br>将文件的<code># include &lt;gnu/stubs-ilp32.h&gt;</code>这段代码注释掉 <br></p><br><br><h2 id="四、运行测试程序" tabindex="-1">四、运行测试程序 <a class="header-anchor" href="#四、运行测试程序" aria-label="Permalink to &quot;四、运行测试程序&quot;">​</a></h2><p>下面提供了多个可以运行测试程序的命令，选择其中一部分运行即可</p><div class="tip custom-block"><p class="custom-block-title">运行程序对处理器的要求</p><p>由于我们的测试程序是可运行的程序，一个可运行程序要求处理器必须能够执行<code>auipc</code>, <code>jal</code>,<code>addi</code>指令</p></div><br><h3 id="运行riscv官方指令集测试集合" tabindex="-1">运行riscv官方指令集测试集合 <a class="header-anchor" href="#运行riscv官方指令集测试集合" aria-label="Permalink to &quot;运行riscv官方指令集测试集合&quot;">​</a></h3><blockquote><p>在项目提供的测试程序中，官方测试集程序是最完备的测试集程序，检测准确度最高</p></blockquote><blockquote><p>务必以该测试集程序作为处理器测试是否通过的标准</p></blockquote><ol><li>克隆riscv官方指令集测试仓库，可以克隆到任意目录</li></ol><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clone</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git@github.com:cs-prj-repo/riscv-tests-am.git</span></span></code></pre></div><ol start="2"><li>运行riscv官方测试集程序</li></ol><p>在命令行或终端下执行下面的代码运行测试集程序</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#运行riscv官方指令集测试程序：</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> xxx/riscv-tests-am</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ARCH=riscv32-npc</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ALL=想要测试的指令</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#示例1-测试add指令实现是否正确：</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> xxx/riscv-tests-am</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ARCH=riscv32-npc</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ALL=add</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#示例2-测试sub指令实现是否正确</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> xxx/riscv-tests-am</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ARCH=riscv32-npc</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ALL=sub</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#示例3-测试所有指令实现是否正确</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> xxx/riscv-tests-am</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ARCH=riscv32-npc</span></span></code></pre></div><br><br><h3 id="运行cpu-tests目录下的测试集程序" tabindex="-1">运行cpu-tests目录下的测试集程序: <a class="header-anchor" href="#运行cpu-tests目录下的测试集程序" aria-label="Permalink to &quot;运行cpu-tests目录下的测试集程序:&quot;">​</a></h3><blockquote><p>cpu-tests目录下的测试程序只是一些简单的测试程序, 测试准确率并不高</p></blockquote><blockquote><p>cpu-tests目录下的测试程序里有一些含有M类指令, 如果你的处理器只支持RV32I，会有一些测试无法通过，这是正常的，请不要担心。</p></blockquote><p>在命令行或终端下执行下面的代码运行测试集程序</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#运行测试集程序的框架代码：</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $TEST_HOME</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/cpu-tests</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ARCH=riscv32-npc</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ALL=想运行的程序</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#示例2-运行string程序：</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $TEST_HOME</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/cpu-tests</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ARCH=riscv32-npc</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ALL=dummy</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#示例1-运行dummy程序：</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $TEST_HOME</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/cpu-tests</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ARCH=riscv32-npc</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ALL=dummy</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#示例3-运行所有程序：</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $TEST_HOME</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/cpu-tests</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ARCH=riscv32-npc</span></span></code></pre></div><br><h3 id="运行benchmarks目录下的测试集程序" tabindex="-1">运行benchmarks目录下的测试集程序: <a class="header-anchor" href="#运行benchmarks目录下的测试集程序" aria-label="Permalink to &quot;运行benchmarks目录下的测试集程序:&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">运行benchmarks下面测试程序时, 暂时先关闭<code>Difftest</code>和<code>波形追踪</code>功能</p></div><p>在命令行或终端下执行下面的代码运行测试集程序:</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#运行coremark测试, 至少需要跑两分钟:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $TEST_HOME</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/benchmarks/coremark</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ARCH=riscv32-npc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#运行dhrystone测试：</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $TEST_HOME</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/benchmarks/dhrystone</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ARCH=riscv32-npc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#运行microbench测试1：</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $TEST_HOME</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/benchmarks/microbench</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ARCH=riscv32-npc</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mainargs=test</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#运行microbench测试2：</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $TEST_HOME</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/benchmarks/microbench</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ARCH=riscv32-npc</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mainargs=train</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">小总结</p><p>通过执行以上命令，我们可以发现下面的规律:</p><p>如果测试程序集里面有多个测试程序 <br>执行<code>make run ARCH=riscv32-npc ALL=xxx</code>只会运行一个叫做<code>xxx</code>的测试程序 <br>执行<code>make run ARCH=riscv32-npc</code> 会运行所有程序</p></div><h3 id="运行csr指令测试程序" tabindex="-1">运行CSR指令测试程序 <a class="header-anchor" href="#运行csr指令测试程序" aria-label="Permalink to &quot;运行CSR指令测试程序&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">CSR测试程序注意事项</p><p>CSR测试程序虽然已经移植，不过仿真框架暂时不支持其测试---全力开发中</p></div><p>当你实现了<code>mret</code>,<code>ecall</code>,<code>csrrw</code>, <code>csrrs</code>指令之后, 可以运行<code>yield-os</code>测试程序。 <br>如果处理器实现正确，测试程序会缓慢出现字母<code>ABABAB</code>的序列。 <br>如果处理器实现出错，这个程序不是那么的好调试，因为涉及到各种陷入，比较复杂---&gt;待改进</p><p>执行下列命令，运行<code>yield-os</code>测试程序</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $TEST_HOME</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/csr-tests/yield-os</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ARCH=riscv32-npc</span></span></code></pre></div><h2 id="五、指定项目运行你的处理器" tabindex="-1">五、指定项目运行你的处理器 <a class="header-anchor" href="#五、指定项目运行你的处理器" aria-label="Permalink to &quot;五、指定项目运行你的处理器&quot;">​</a></h2><p>首先在<code>single-cycle-cpu/IP</code>目录下面新建一个目录，目录的名称不作任何要求。 <br>下文使用<code>your_cpu_dir</code>进行代指, 将你的处理器代码全部放到<code>your_cpu_dir</code>目录下面 最后再通过simulator/Makefile中的<code>CPU_DIR</code>变量为你的处理器目录路径，来指定项目运行你的处理器</p><div class="warning custom-block"><p class="custom-block-title">注意define.v文件必须和你的处理器同在一个目录下面</p></div><div class="tip custom-block"><p class="custom-block-title">示例</p><p>项目通过<code>simulator/Makefile</code>中的<code>CPU_DIR :=$(CPU_HOME)/IP/single-cycle</code>指定了项目会运行<code>single-cycle目录下的处理器</code></p><p>通过修改<code>CPU_DIR :=$(CPU_HOME)/IP/你的处理器目录名字</code>, 可以指定项目运行<code>你的处理器</code></p><p><br>示例： 若<code>simulator/Makefile</code>中的<code>CPU_DIR :=$(CPU_HOME)/IP/AAA</code>, 则项目会运行<code>AAA</code>目录下的处理器</p></div><h2 id="六、将你的处理器接入仿真环境" tabindex="-1">六、将你的处理器接入仿真环境 <a class="header-anchor" href="#六、将你的处理器接入仿真环境" aria-label="Permalink to &quot;六、将你的处理器接入仿真环境&quot;">​</a></h2><p>为了支持所有的单周期处理器都可以接入该仿真、测试环境, 仿真环境对运行的处理器有一定的要求</p><h3 id="_1-仿真框架对于处理器最顶层模块名称top-module-name的要求" tabindex="-1">1. 仿真框架对于处理器最顶层模块名称<code>TOP_Module_Name</code>的要求 <a class="header-anchor" href="#_1-仿真框架对于处理器最顶层模块名称top-module-name的要求" aria-label="Permalink to &quot;1. 仿真框架对于处理器最顶层模块名称\`TOP_Module_Name\`的要求&quot;">​</a></h3><p>为了支持所有的单周期处理器都可以接入该仿真、测试环境，我们预先设定了一个最顶层的仿真模块名称，即<code>TOP_Module_Name=CPU</code>也就是说处理器最顶层模块名称必须是<code>CPU</code></p><div class="warning custom-block"><p class="custom-block-title">仿真框架只对TOP_Module_Name有此要求，对所有的verilog代码文件名，其他模块名称均没有任何要求。</p></div><div class="tip custom-block"><p class="custom-block-title">自定义你的处理器TOP_Module_Name</p><p>项目通过<code>simulator/Makefile</code>中的<code>TOPNAME :=CPU</code>指定了处理器最顶层模块名称<code>TOP_Module_Name</code>必须为<code>CPU</code></p><p>通过修改<code>TOPNAME :=你写的模块名</code>, 可以指定处理器最顶层模块名称为<code>你写的模块名</code></p><p><br>示例： 若<code>simulator/Makefile</code>中的<code>TOPNAME :=AAA</code>, 则处理器最顶层模块名称需要为<code>AAA</code></p></div><br><h3 id="_2-仿真框架对处理器最顶层模块的信号要求" tabindex="-1">2. 仿真框架对处理器最顶层模块的信号要求 <a class="header-anchor" href="#_2-仿真框架对处理器最顶层模块的信号要求" aria-label="Permalink to &quot;2. 仿真框架对处理器最顶层模块的信号要求&quot;">​</a></h3><p>无论处理器顶层模块的模块名是什么，它都必须带有下面三个信号<code>clk</code>, <code>rst</code>, <code>cur_pc_for_simulator</code> 如果你对仿真框架比较熟悉，</p><div class="language-verilog vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">verilog</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">module</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TOP_Module_Name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    input</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  wire</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         clk,                    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//该信号是仿真框架提供的时钟信号</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    input</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  wire</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         rst,                    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//该信号是仿真框架提供的复位信号</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    output</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> wire</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]  cur_pc_for_simulator    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//该信号需要连接当前的pc值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">endmodule</span></span></code></pre></div><br><h3 id="_3-仿真框架中clk和rst信号的使用要求" tabindex="-1">3. 仿真框架中<code>clk</code>和<code>rst</code>信号的使用要求 <a class="header-anchor" href="#_3-仿真框架中clk和rst信号的使用要求" aria-label="Permalink to &quot;3. 仿真框架中\`clk\`和\`rst\`信号的使用要求&quot;">​</a></h3><p>仿真框架<code>clk</code>和<code>rst</code>信号的使用要求如下：</p><div class="language-verilog vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">verilog</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//我们只捕捉时钟上升沿的信号进行处理，示例如下</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">always</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">posedge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clk) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">begin</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//rst在高电平时进行复位</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">always</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">posedge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clk) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">begin</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rst) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">begin</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //高电平时进行复位</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        regfile[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 32&#39;h0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> begin</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //other code</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><br><h3 id="_4-仿真框架对于pc复位值的要求" tabindex="-1">4. 仿真框架对于pc复位值的要求 <a class="header-anchor" href="#_4-仿真框架对于pc复位值的要求" aria-label="Permalink to &quot;4. 仿真框架对于pc复位值的要求&quot;">​</a></h3><p><code>pc</code>初始复位值必须为<code>0x80000000</code></p><div class="language-verilog vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">verilog</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">always</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">posedge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clk) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">begin</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rst) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">begin</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        pc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 32&#39;h80000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//32位操作系统</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><br><h3 id="_5-接入仿真框架的dpi-c机制" tabindex="-1">5. 接入仿真框架的DPI-C机制 <a class="header-anchor" href="#_5-接入仿真框架的dpi-c机制" aria-label="Permalink to &quot;5. 接入仿真框架的DPI-C机制&quot;">​</a></h3><p>我们使用Verilator的DPI-C机制将处理器接入到仿真环境，并访问仿真环境的内存。</p><br><h4 id="对于取指阶段" tabindex="-1">对于取指阶段 <a class="header-anchor" href="#对于取指阶段" aria-label="Permalink to &quot;对于取指阶段&quot;">​</a></h4><p>由于内存是仿真环境提供的，当我们从内存中进行取指时，需要通过DPI-C机制访问内存，使用方法参考下列代码</p><div class="language-verilog vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">verilog</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">module</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //其他信号</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">import </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;DPI-C&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int  dpi_mem_read 	(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int addr  , </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int len);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">assign</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> instr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dpi_mem_read(pc, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">endmodule</span></span></code></pre></div><br><h4 id="对于寄存器文件的访问" tabindex="-1">对于寄存器文件的访问 <a class="header-anchor" href="#对于寄存器文件的访问" aria-label="Permalink to &quot;对于寄存器文件的访问&quot;">​</a></h4><p>由于仿真环境在进行指令验证的时候，需要获取到寄存器文件的内存，所以我们要通过DPI-C机制将寄存器文件信号传递给仿真环境，使用方法参考下列代码</p><div class="language-verilog vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">verilog</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">module</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> regfile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //其他信号</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">reg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] regfile[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">import </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;DPI-C&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> void dpi_read_regfile(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> logic [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] a []);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">initial</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> begin</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	dpi_read_regfile(regfile);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">endmodule</span></span></code></pre></div><br><h4 id="对于内存的访问" tabindex="-1">对于内存的访问 <a class="header-anchor" href="#对于内存的访问" aria-label="Permalink to &quot;对于内存的访问&quot;">​</a></h4><p>当处理器需要读写内存的时候，也需要通过DPI-C机制从仿真环境获取到内存数据，使用方法参考下列代码</p><div class="language-verilog vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">verilog</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">module</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> memory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //其他信号</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">import </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;DPI-C&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> void dpi_mem_write(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int addr, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int data, int len);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">import </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;DPI-C&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int  dpi_mem_read (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int addr  , </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int len);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//读取内存，每次读取4个字节，然后根据需要，再对读出来的数据进行处理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">wire</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 从内存中读出来的数据(32bit) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dpi_mem_read(要读取的内存地址, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//写入</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">always</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">posedge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clk) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">begin</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(如果要从内存中读取一个字节) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">begin</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		dpi_mem_write(写入地址, 要写入的数据(32bit), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(如果要从内存中读取两个字节) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">begin</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		dpi_mem_write(要写入的地址, 要写入的数据(32bit), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);		</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(如果要从内存中读取四个字节) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">begin</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		dpi_mem_write(要写入的地址, 要写入的数据(32bit), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);				</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><br><h2 id="七、再次运行项目" tabindex="-1">七、再次运行项目 <a class="header-anchor" href="#七、再次运行项目" aria-label="Permalink to &quot;七、再次运行项目&quot;">​</a></h2><p>当将处理器按照文档要求接入到仿真环境以后，我们的准备工作就一切就绪了，下面就要开始在该项目框架下验证我们自己的处理器了。</p><p>执行下面命令，再次运行项目</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $SIM_HOME</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span></span></code></pre></div><p>当项目运行成功后，使用上文中的riscv官方指令测试集即<code>riscv-tests-am</code>来验证你的处理器实现是否正确</p><h2 id="八、-失败调试-如何查看和阅读波形" tabindex="-1">八、[失败调试]如何查看和阅读波形 <a class="header-anchor" href="#八、-失败调试-如何查看和阅读波形" aria-label="Permalink to &quot;八、[失败调试]如何查看和阅读波形&quot;">​</a></h2><p>当处理器运行出现一个红色的<code>HIT BAD TRAP</code>字样时，说明处理器执行的指令出错。 当指令出错的时候，我们首先可以根据Difftest打印的错误信息来追踪错误指令，当确定了错误的指令后，可以通过查看波形来排查错误。</p><h3 id="_1-difftest检测和波形信息说明" tabindex="-1">1. Difftest检测和波形信息说明 <a class="header-anchor" href="#_1-difftest检测和波形信息说明" aria-label="Permalink to &quot;1. Difftest检测和波形信息说明&quot;">​</a></h3><p>我们使用的Difftest是在每一条指令执行完毕后，对比一个<code>参考处理器</code>和<code>你的处理器</code>的寄存器和<code>PC</code>状态信息。</p><p>由于大多数指令都会修改寄存器和PC的状态，所以当这样的一条执行完毕后，我们就可以立即比对他们的寄存器和PC状态信息，如果发现处理器实现出错，那么立刻就可以捕捉到这样的错误。</p><p>一个例外是Load和Store指令。 <br>Store指令是将寄存器的数据写入到内存中，并不会更改寄存器的状态，所以Difftest无法不会对Store指令进行检测。 <br>Load指令是将内存里面的数据读取到寄存器中，当它发生错误时，有可能不是Load指令自身的问题，而是Store指令出了错。 <br>按照大多数程序执行时的特性，存到内存里面的数据会很快会被指令取出来使用，如果在Load指令将数据从内存里面取到寄存器时出现错误，那么可以推测是Load或Store指令出错。</p><p>依据Difftest的机制，当Difftest捕捉到错误的时候，我们结束程序的波形追踪，此时波形文件的最后一条波形就是DIfftest出错的那条指令。 <br>对于非Load和非Store指令来说，波形文件的最后一条波形就是出错的那条指令 <br>对于Load指令来说，有可能不是Load指令出错，而是Store指令出错。如果是Store指令的错误，需要去看最后一条波形的前一些周期，即Store指令的波形。</p><div class="tip custom-block"><p class="custom-block-title">Diffetst和波形文件总结</p><p>对于非Load和非Store指令来说，波形文件的最后一条波形就是出错的那条指令</p><p>对于Load指令来说，有可能不是Load指令出错，而是Store指令出错。如果是Store指令的错误，需要去看波形文件最后一条波形的前一些周期的Store指令的波形。</p><p>以上是错误指令在波形文件的大概位置，具体是哪一条波形，我们还需要通过<code>pc</code>和<code>instr</code>进行精确定位。</p></div><h3 id="_2-如何查看波形" tabindex="-1">2. 如何查看波形 <a class="header-anchor" href="#_2-如何查看波形" aria-label="Permalink to &quot;2. 如何查看波形&quot;">​</a></h3><p>每当测试程序成功运行完毕并退出后，仿真测试框架就会将该次处理器运行的波形信息保存下来 此时执行如下命令，查看波形</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $SIM_HOME &amp;&amp; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sim</span></span></code></pre></div><h3 id="_3-如何高效查看波形" tabindex="-1">3. 如何高效查看波形 <a class="header-anchor" href="#_3-如何高效查看波形" aria-label="Permalink to &quot;3. 如何高效查看波形&quot;">​</a></h3><p><code>gtkwave</code>在左下角有一个信号搜索框可以进行筛选，可以筛选出自己想要看的信号波形。</p>`,138))])}const u=n(k,[["render",r]]);export{y as __pageData,u as default};
